  /**
   * Get the row sections for the canvas.
   */
  get rowSections(): GridCanvas.ISections {
    return this._rowSections;
  }

  /**
   * Set the row sections for the canvas.
   */
  set rowSections(value: GridCanvas.ISections) {
    // Null and undefined are treated the same.
    value = value || null;

    // Lookup the old sections.
    let old = this._rowSections;

    // Do nothing if the sections do not change.
    if (old === value) {
      return;
    }

    // Disconnect the signal handlers from the old sections.
    if (old) {
      old.sectionsResized.disconnect(this._onRowsResized, this);
    }

    // Connect the signal handlers for the new sections.
    if (value) {
      value.sectionsResized.connect(this._onRowsResized, this);
    }

    // Update the internal sections reference.
    this._rowSections = value;

    // Schedule an update of the canvas.
    this.update();
  }

  /**
   * Get the column sections for the canvas.
   */
  get columnSections(): GridCanvas.ISections {
    return this._columnSections;
  }

  /**
   * Set the column sections for the canvas.
   */
  set columnSections(value: GridCanvas.ISections) {
    // Null and undefined are treated the same.
    value = value || null;

    // Lookup the old sections.
    let old = this._columnSections;

    // Do nothing if the sections do not change.
    if (old === value) {
      return;
    }

    // Disconnect the signal handlers from the old sections.
    if (old) {
      old.sectionsResized.disconnect(this._onColumnsResized, this);
    }

    // Connect the signal handlers for the new sections.
    if (value) {
      value.sectionsResized.connect(this._onColumnsResized, this);
    }

    // Update the internal sections reference.
    this._columnSections = value;

    // Schedule an update of the canvas.
    this.update();
  }
/**
 *
 */
export
abstract class GridHeader extends Widget {
  /**
   *
   */
  sectionsResized: ISignal<this, GridHeader.ISectionRange>;

  /**
   *
   */
  model: DataModel;

  /**
   *
   */
  scrollPosition: number;

  /**
   *
   */
  scrollSize: number;

  /**
   *
   */
  abstract sectionPosition(index: number): number;

  /**
   *
   */
  abstract sectionSize(index: number): number;

  /**
   *
   */
  abstract sectionAt(position: number): number;
}


//
defineSignal(GridHeader.prototype, 'sectionsResized');


/**
 *
 */
export
namespace GridHeader {
  /**
   *
   */
  export
  interface ISectionRange {
    /**
     *
     */
    start: number;

    /**
     *
     */
    end: number;
  }
}
/**
 *
 */
export
class DataGrid extends Widget {
  /**
   *
   */
  constructor() {
    super();
    this.addClass(DATA_GRID_CLASS);

    let canvas = new GridCanvas();
    canvas.addClass(GRID_CANVAS_CLASS);

    let layout = new BoxLayout();
    layout.addWidget(canvas);

    this.layout = layout;
  }

  /**
   *
   */
  get model(): DataModel {
    return null;
  }

  /*
   *
   */
  set model(value: DataModel) {
    value = value || null;
    if (this._model === value) {
      return;
    }
    // TODO handle signals
    this._model = value;
  }

  /**
   *
   */
  get rowHeader(): GridHeader {
    return this._rowHeader;
  }

  /**
   *
   */
  set rowHeader(value: GridHeader) {
    value = value || null;
    if (this._rowHeader === value) {
      return;
    }
    // TODO handle signals
    this._rowHeader = value;
  }

  /**
   *
   */
  get columnHeader(): GridHeader {
    return this._columnHeader;
  }

  /**
   *
   */
  set columnHeader(value: GridHeader) {
    value = value || null;
    if (this._columnHeader === value) {
      return;
    }
    // TODO handle signals
    this._columnHeader = value;
  }

  private _model: DataModel = null;
  private _rowHeader: GridHeader = null;
  private _columnHeader: GridHeader = null;
}


  // /**
  //  * A span object used by the SectionList.
  //  */
  // export
  // interface ISpan {
  //   /**
  //    * The total number of sections contained by the subtree.
  //    *
  //    * If the span is a leaf, this is the number of equal sized
  //    * sections covered by the span.
  //    *
  //    * This is always `> 0`.
  //    */
  //   count: number;

  //   /**
  //    * The total size of all sections contained by the subtree.
  //    *
  //    * If the span is a leaf, this is the total size of the equal sized
  //    * sections covered by the span.
  //    */
  //   size: number;

  //   /**
  //    * The level of the span in the tree.
  //    *
  //    * A `0` level indicates the span is a leaf.
  //    *
  //    * This is always `>= 0`.
  //    */
  //   level: number;

  //   /**
  //    * The left subtree of the span.
  //    *
  //    * This will be `null` IFF the span is a leaf.
  //    */
  //   left: ISpan | null;

  //   /**
  //    * The right subtree of the span.
  //    *
  //    * This will be `null` IFF the span is a leaf.
  //    */
  //   right: ISpan | null;
  // }

  // /**
  //  * Create a new leaf span with the given count and section size.
  //  */
  // export
  // function createLeaf(count: number, size: number): ISpan {
  //   return { count, size: count * size, level: 0, left: null, right: null };
  // }

  // /**
  //  * Find the index of the section which covers the given offset.
  //  *
  //  * The offset must be within range of the given span.
  //  */
  // export
  // function indexOf(span: ISpan, offset: number): number {
  //   let index = 0;
  //   while (span.level !== 0) {
  //     if (offset < span.left!.size) {
  //       span = span.left!;
  //     } else {
  //       index += span.left!.count;
  //       offset -= span.left!.size;
  //       span = span.right!;
  //     }
  //   }
  //   return index + Math.floor(offset * span.count / span.size);
  // }

  // /**
  //  * Find the offset of the section at the given index.
  //  *
  //  * The index must be within range of the given span.
  //  */
  // export
  // function offsetOf(span: ISpan, index: number): number {
  //   let offset = 0;
  //   while (span.level !== 0) {
  //     if (index < span.left!.count) {
  //       span = span.left!;
  //     } else {
  //       index -= span.left!.count;
  //       offset += span.left!.size;
  //       span = span.right!;
  //     }
  //   }
  //   return offset + index * span.size / span.count;
  // }

  // /**
  //  * Find the size of the section at the given index.
  //  *
  //  * The index must be within range of the given span.
  //  */
  // export
  // function sizeOf(span: ISpan, index: number): number {
  //   while (span.level !== 0) {
  //     if (index < span.left!.count) {
  //       span = span.left!;
  //     } else {
  //       index -= span.left!.count;
  //       span = span.right!;
  //     }
  //   }
  //   return span.size / span.count;
  // }

  // /**
  //  * Insert new sections into the given subtree.
  //  *
  //  * The index and count must be greater than zero.
  //  *
  //  * The return value is the span which should take the place of the
  //  * original span in the tree.
  //  */
  // export
  // function insert(span: ISpan, index: number, count: number, size: number): ISpan {
  //   // If the span is a leaf, the insert target has been found.
  //   if (span.level === 0) {
  //     // Add to the span count if the section sizes are the same.
  //     if (size === span.size / span.count) {
  //       span.count += count;
  //       span.size += count * size;
  //       return span;
  //     }

  //     // If the index is zero, the new span goes before the current span,
  //     // which requires a new branch node to be added to the tree.
  //     if (index === 0) {
  //       return createBranch(createLeaf(count, size), span);
  //     }

  //     // If the index is greater than the span count, the new span goes
  //     // after the current span, which also requires a new branch node.
  //     if (index >= span.count) {
  //       return createBranch(span, createLeaf(count, size));
  //     }

  //     // Otherwise, the current span must be split and the new span
  //     // added to the middle. This requires several new nodes.
  //     let subLeft = createLeaf(count, size);
  //     let subRight = createLeaf(span.count - index, span.size / span.count);
  //     let newLeft = createLeaf(index, span.size / span.count);
  //     let newRight = createBranch(subLeft, subRight);

  //     // Update the leaf span to be a branch.
  //     return updateBranch(span, newLeft, newRight);
  //   }

  //   // Handle the case where the insert is directly between two leaf
  //   // spans, and the left span span can be augmented in-place. The
  //   // right span is handled by the zero-level case above.
  //   if (span.level === 1 && index === span.left!.count) {
  //     if (size === span.left!.size / span.left!.count) {
  //       span.left!.count += count;
  //       span.left!.size += count * size;
  //       return updateBranch(span, span.left, span.right);
  //     }
  //   }

  //   // Otherwise, recurse down the appropriate branch.
  //   if (index < span.left!.count) {
  //     span.left = insert(span.left!, index, count, size);
  //   } else {
  //     span.right = insert(span.right!, index - span.left!.count, count, size);
  //   }

  //   // Always rebalance the branch after an insert.
  //   return rebalance(span);
  // }

  // /**
  //  * Create a new branch span from the given left and right children.
  //  */
  // function createBranch(left: ISpan, right: ISpan): ISpan {
  //   let count = left.count + right.count;
  //   let size = left.size + right.size;
  //   let level = Math.max(left.level, right.level) + 1;
  //   return { count, size, level, left, right };
  // }

  // /**
  //  * Update a span to be branch with the given left and right children.
  //  *
  //  * This returns the updated span as a convenience.
  //  */
  // function updateBranch(span: ISpan, left: ISpan, right: ISpan): ISpan {
  //   span.count = left.count + right.count;
  //   span.size = left.size + right.size;
  //   span.level = Math.max(left.level, right.level) + 1;
  //   span.left = left;
  //   span.right = right;
  //   return span;
  // }


  // const colors = [
  //   'red', 'green', 'blue', 'yellow', 'orange', 'cyan'
  // ];

  // let ci = 0;

  // export
  // function nextColor(): string {
  //   return colors[ci++ % colors.length];
  // }

  // const COL_WIDTH = 60;
  // const ROW_HEIGHT = 20;

  // export
  // function rowSize(index: number): number {
  //   return ROW_HEIGHT;
  // }

  // export
  // function columnSize(index: number): number {
  //   return COL_WIDTH;
  // }

  // export
  // function rowPosition(index: number): number {
  //   return index * ROW_HEIGHT;
  // }

  // export
  // function columnPosition(index: number): number {
  //   return index * COL_WIDTH;
  // }

  // export
  // function rowAt(position: number): number {
  //   if (position < 0) {
  //     return -1;
  //   }
  //   return Math.floor(position / ROW_HEIGHT);
  // }

  // export
  // function columnAt(position: number): number {
  //   if (position < 0) {
  //     return -1;
  //   }
  //   return Math.floor(position / COL_WIDTH);
  // }
