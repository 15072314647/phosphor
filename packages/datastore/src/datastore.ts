/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2018, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
import {
  ISignal
} from '@phosphor/signaling';

import {
  ITable
} from './table';


/**
 * A multi-user collaborative datastore.
 *
 * #### Notes
 * A datastore is structured in a maximally flat way using an object
 * hierarchy of tables, records, and fields. Internally, this object
 * hierarchy is synchronized among all users via CRDT algorithms.
 *
 * https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type
 * https://hal.inria.fr/file/index/docid/555588/filename/techreport.pdf
 */
export
interface IDatastore {
  /**
   * A signal emitted when changes are made to the datastore.
   *
   * #### Notes
   * This signal is emitted either at the end of a local mutation,
   * or after a remote mutation has been applied.
   *
   * The payload represents the set of local changes that were made
   * to bring the datastore to its current state.
   *
   * #### Complexity
   * `O(1)`
   */
  readonly changed: ISignal<IDatastore, IDatastore.IChangedArgs>;

  /**
   * The unique id of the datastore.
   *
   * #### Notes
   * The datastore id is assigned by the patch server and is unique
   * among all other stores serviced by that server. It is not safe
   * to assume that the id is a GUID.
   *
   * #### Complexity
   * `O(1)`
   */
  readonly id: string;

  /**
   * Make changes to the the datastore.
   *
   * @param message - The message to associate with the patch.
   *   This should be a simple human readable description.
   *
   * @param fn - The function that will edit the datastore. The unique
   *   patch id is provided as the first argument. All changes made by
   *   the function are associated with the given patch id.
   *
   * @throws An exception if `mutate` is called recursively.
   *
   * #### Notes
   * Except for `undo` and `redo`, the datastore can only be modified
   * during a `mutate` operation.
   *
   * The provided mutation function is invoked synchronously.
   *
   * If changes are made, the `changed` signal will be emitted before
   * this method returns.
   */
  mutate(message: string, fn: (patchId: string) => void): void;

  /**
   * Undo a patch that was previously applied.
   *
   * @param patchId - The patch to undo.
   *
   * @returns A promise which resolves when the action is complete.
   *   The result will be `true` if the patch was undone, or `false`
   *   if the patch was already undone. The promise will reject if
   *   the given patch does not exist.
   *
   * @throws An exception if `undo` is called during a mutation.
   *
   * #### Notes
   * If changes are made, the `changed` signal will be emitted before
   * the promise resolves.
   */
  undo(patchId: string): Promise<boolean>;

  /**
   * Redo a patch that was previously undone.
   *
   * @param patchId - The patch(es) to redo.
   *
   * @returns A promise which resolves when the action is complete.
   *   The result will be `true` if the patch was redone, or `false`
   *   if the patch was not already undone. The promise will reject
   *   if the given patch does not exist.
   *
   * @throws An exception if `redo` is called during a mutation.
   *
   * #### Notes
   * If changes are made, the `changed` signal will be emitted before
   * the promise resolves.
   */
  redo(patchId: string): Promise<boolean>;

  /**
   * Get the table for a particular schema.
   *
   * @param schema - The schema of interest.
   *
   * @returns The table for the specified schema, or `undefined` if
   *   no such table exists.
   *
   * #### Notes
   * This method may be called at any time.
   *
   * #### Complexity
   * `O(1)`
   */
  getTable<S extends ITable.Schema>(schema: S): ITable<S> | undefined;

  /**
   * Create a new table for a schema.
   *
   * @param schema - The schema of interest.
   *
   * @returns A new table for the specified schema.
   *
   * @throws An exception if a table for the schema already exists.
   *
   * #### Notes
   * This method may only be called during `mutate`.
   *
   * Once created, a table cannot be deleted.
   *
   * #### Complexity
   * `O(1)`
   */
  createTable<S extends ITable.Schema>(schema: S): ITable<S>;
}


/**
 * The namespace for the `IDatastore` interface statics.
 */
export
namespace IDatastore {
  /**
   * The arguments object for the datastore `changed` signal.
   */
  export
  interface IChangedArgs {
    /**
     * Whether the change was generated by mutation, undo, or redo.
     */
    readonly type: 'mutate' | 'undo' | 'redo';

    /**
     * The id of the datastore which generated the current change.
     */
    readonly storeId: string;

    /**
     * The id of the patch associated with the change.
     */
    readonly patchId: string;

    /**
     * The schema ids of the tables created during the change.
     */
    readonly newTables: ReadonlyArray<string>;

    /**
     * A mapping of schema id to table changes.
     */
    readonly tableChanges: TableChangesBySchemaId;
  }

  /**
   * A type alias for a mapping of table changes.
   */
  export
  type TableChangesBySchemaId = {
    /**
     * An index signature which maps schema ids to table changes.
     */
    readonly [schemaId: string]: TableChange<ITable.Schema>;
  };

  /**
   * A type alias for changes to a specific table.
   */
  export
  type TableChange<S extends ITable.Schema> = {
    /**
     * The ids of the records created during the change.
     */
    readonly newRecords: ReadonlyArray<string>;

    /**
     * A mapping of record id to record changes.
     */
    readonly recordChanges: RecordChangesByRecordId<S>;
  };

  /**
   * A type alias for a mapping of record changes.
   */
  export
  type RecordChangesByRecordId<S extends ITable.Schema> = {
    /**
     * An index signature which maps record ids to record changes.
     */
    readonly [recordId: string]: RecordChange<S>;
  };

  /**
   * A type alias for changes to a specific record.
   */
  export
  type RecordChange<S extends ITable.Schema> = {
    /**
     * The change state of a record.
     */
    readonly [K in keyof S['fields']]?: S['fields'][K]['@@ChangeType'];
  };
}


/**
 *
 */
export
function createDatastore(): Promise<IDatastore> {
  throw '';
}
