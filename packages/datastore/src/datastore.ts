/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2018, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
import {
  IIterable
} from '@phosphor/algorithm';

import {
  ISignal
} from '@phosphor/signaling';

import {
  ITable
} from './table';


/**
 * A multi-user collaborative datastore.
 *
 * #### Notes
 * A datastore is structured in a maximally flat way using an object
 * hierarchy of tables, records, and fields. Internally, this object
 * hierarchy is synchronized among all users via CRDT algorithms.
 *
 * https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type
 * https://hal.inria.fr/file/index/docid/555588/filename/techreport.pdf
 */
export
interface IDatastore extends IIterable<ITable<ITable.Schema>> {
  /**
   * A signal emitted when changes are made to the datastore.
   *
   * #### Notes
   * This signal is emitted either at the end of a local mutation,
   * or after a remote mutation has been applied.
   *
   * The payload represents the set of local changes that were made
   * to bring the datastore to its current state.
   *
   * #### Complexity
   * `O(1)`
   */
  readonly changed: ISignal<IDatastore, IDatastore.IChangedArgs>;

  /**
   * The unique id of the datastore.
   *
   * #### Notes
   * The datastore id is assigned by the patch server and is unique
   * among all other collaborating peers.
   *
   * #### Complexity
   * `O(1)`
   */
  readonly id: number;

  /**
   * Make changes to the the datastore.
   *
   * @param message - The message to associate with the patch.
   *   This should be a simple human readable description.
   *
   * @param fn - The function that will edit the datastore. The unique
   *   patch id is provided as the first argument. All changes made by
   *   the function are associated with the given patch id.
   *
   * @throws An exception if `mutate` is called recursively.
   *
   * #### Notes
   * Except for `undo` and `redo`, the datastore can only be modified
   * during a `mutate` operation.
   *
   * The provided mutation function is invoked synchronously.
   *
   * If changes are made, the `changed` signal will be emitted before
   * this method returns.
   */
  mutate(message: string, fn: (patchId: string) => void): void;

  /**
   * Undo a patch that was previously applied.
   *
   * @param patchId - The patch to undo.
   *
   * @returns A promise which resolves when the action is complete.
   *   The result will be `true` if the patch was undone, or `false`
   *   if the patch was already undone. The promise will reject if
   *   the given patch does not exist.
   *
   * @throws An exception if `undo` is called during a mutation.
   *
   * #### Notes
   * If changes are made, the `changed` signal will be emitted before
   * the promise resolves.
   */
  undo(patchId: string): Promise<boolean>;

  /**
   * Redo a patch that was previously undone.
   *
   * @param patchId - The patch(es) to redo.
   *
   * @returns A promise which resolves when the action is complete.
   *   The result will be `true` if the patch was redone, or `false`
   *   if the patch was not already undone. The promise will reject
   *   if the given patch does not exist.
   *
   * @throws An exception if `redo` is called during a mutation.
   *
   * #### Notes
   * If changes are made, the `changed` signal will be emitted before
   * the promise resolves.
   */
  redo(patchId: string): Promise<boolean>;

  /**
   * Get the table for a particular schema.
   *
   * @param schema - The schema of interest.
   *
   * @returns The table for the specified schema, or `undefined` if
   *   no such table has been created.
   *
   * #### Complexity
   * `O(1)`
   */
  getTable<S extends ITable.Schema>(schema: S): ITable<S> | undefined;

  /**
   * Create a table for a particular schema.
   *
   * @param schema - The schema of interest.
   *
   * @returns A new table for the specified schema.
   *
   * #### Notes
   * If a table for the specified schema already exists, the existing
   * table is returned.
   *
   * #### Complexity
   * `O(1)`
   */
  createTable<S extends ITable.Schema>(schema: S): ITable<S>;
}


/**
 * The namespace for the `IDatastore` interface statics.
 */
export
namespace IDatastore {
  /**
   * The arguments object for the datastore `changed` signal.
   */
  export
  interface IChangedArgs {
    /**
     * Whether the change was generated by mutation, undo, or redo.
     */
    readonly type: 'mutate' | 'undo' | 'redo';

    /**
     * The id of the patch associated with the change.
     */
    readonly patchId: string;

    /**
     * A mapping of schema id to table change set.
     */
    readonly changes: ChangeSet;
  }

  /**
   * A type alias for a datastore change set.
   */
  export
  type ChangeSet = {
    readonly [schemaId: string]: ITable.ChangeSet<ITable.Schema>;
  };
}


/**
 *
 */
export
function createDatastore(schemas: ReadonlyArray<ITable.Schema>): Promise<IDatastore> {
  throw '';
}
