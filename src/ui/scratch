

//   *
//    * Ensure the tab for the specified content widget is selected.
//    *
//    * @param widget - The content widget of interest.
//    *
//    * #### Notes
//    * If the widget is not contained in the dock panel, or is already
//    * the selected tab in its respective tab panel, this is a no-op.

//   selectWidget(widget: Widget): void {
//     DockPanelPrivate.selectWidget(this, widget);
//   }





//   /**
//    * Ensure the given widget is the current widget in its tab panel.
//    *
//    * This is a no-op if the widget is not contained in the dock panel.
//    */
//   export
//   function selectWidget(owner: DockPanel, widget: Widget): void {
//     if (!dockPanelContains(owner, widget)) return;
//     (widget.parent.parent as DockTabPanel).currentWidget = widget;
//   }



//   /**
//    * Throw an internal dock panel error.
//    */
//   function internalError(): void {
//     throw new Error('Internal DockPanel Error.');
//   }



//   /**
//    * Find the ancestor dock tab panel for the given widget.
//    *
//    * This assumes the widget already belongs to a dock panel, and will
//    * throw an error if that assumption does not hold.
//    */
//   function findTabPanel(widget: Widget): DockTabPanel {
//     let stack = widget.parent;
//     if (!stack) {
//       internalError();
//     }
//     let tabs = stack.parent;
//     if (!(tabs instanceof DockTabPanel)) {
//       internalError();
//     }
//     return tabs as DockTabPanel;
//   }





//   /**
//    * The current tab drag object.
//    */
//   let currentDrag: Drag = null;

//   /**
//    * Create a new tab panel for a dock panel.
//    */
//   function createTabPanel(): DockTabPanel {
//     let panel = new DockTabPanel();
//     panel.tabBar.tabDetachRequested.connect(onTabDetachRequested);
//     panel.stackedPanel.widgetRemoved.connect(onWidgetRemoved);
//     return panel;
//   }

//   /**
//    * Remove an empty dock tab panel from the hierarchy.
//    *
//    * This ensures that the hierarchy is kept consistent by merging an
//    * ancestor split panel when it contains only a single child widget.
//    */
//   function removeTabPanel(tabPanel: DockTabPanel): void {
//     // Assert the tab panel is empty.
//     if (tabPanel.childCount() !== 0) {
//       internalError();
//     }

//     // If the parent of the tab panel is a dock panel, just remove it.
//     if (tabPanel.parent instanceof DockPanel) {
//       setRoot(tabPanel.parent as DockPanel, null);
//       tabPanel.dispose();
//       return;
//     }

//     // Assert the tab panel parent is a dock split panel.
//     if (!(tabPanel.parent instanceof DockSplitPanel)) {
//       internalError();
//     }

//     // Cast the tab panel parent to a dock split panel.
//     let splitPanel = tabPanel.parent as DockSplitPanel;

//     // Assert the split panel has at least two children.
//     if (splitPanel.childCount() < 2) {
//       internalError();
//     }

//     // Dispose the tab panel to ensure its resources are released.
//     tabPanel.dispose();

//     // If the split panel still has multiple children, there is
//     // nothing more to do.
//     if (splitPanel.childCount() > 1) {
//       return;
//     }

//     // Extract the remaining child from the split panel.
//     let child = splitPanel.childAt(0);

//     // Assert the remaining child is a proper panel type.
//     if (!(child instanceof DockTabPanel) && !(child instanceof DockSplitPanel)) {
//       internalError();
//     }

//     // If the parent of the split panel is a dock panel, replace it.
//     if (splitPanel.parent instanceof DockPanel) {
//       setRoot(splitPanel.parent as DockPanel, child as RootPanel);
//       splitPanel.dispose();
//       return;
//     }

//     // Assert the split panel parent is a dock split panel.
//     if (!(splitPanel.parent instanceof DockSplitPanel)) {
//       internalError();
//     }

//     // Cast the split panel parent to a dock split panel.
//     let grandPanel = splitPanel.parent as DockSplitPanel;

//     // If the child is a dock tab panel, replace the split panel.
//     if (child instanceof DockTabPanel) {
//       let sizes = grandPanel.sizes();
//       let index = grandPanel.childIndex(splitPanel);
//       splitPanel.parent = null;
//       grandPanel.insertChild(index, child);
//       grandPanel.setSizes(sizes);
//       splitPanel.dispose();
//       return;
//     }

//     // Cast the child to a dock split panel.
//     let childSplit = child as DockSplitPanel;

//     // Child splitters have an orthogonal orientation to their parent.
//     // Assert the orientation of the child matches the grand parent.
//     if (childSplit.orientation !== grandPanel.orientation) {
//       internalError();
//     }

//     // The grand children can now be merged with their grand parent.
//     // Start by fetching the relevant current sizes and insert index.
//     let index = grandPanel.childIndex(splitPanel);
//     let childSizes = childSplit.sizes();
//     let grandSizes = grandPanel.sizes();

//     // Remove the split panel and store its share of the size.
//     splitPanel.parent = null;
//     let sizeShare = arrays.removeAt(grandSizes, index);

//     // Merge the grand children and maintain their relative size.
//     for (let i = 0; childSplit.childCount() !== 0; ++i) {
//       grandPanel.insertChild(index + i, childSplit.childAt(0));
//       arrays.insert(grandSizes, index + i, sizeShare * childSizes[i]);
//     }

//     // Update the grand parent sizes and dispose the removed panel.
//     grandPanel.setSizes(grandSizes);
//     splitPanel.dispose();
//   }

//   /**
//    * Handle the `tabDetachRequested` signal from a dock tab bar.
//    */
//   function onTabDetachRequested(sender: TabBar, args: ITabDetachArgs): void {
//     // Do nothing if a drag is already in progress.
//     if (currentDrag) {
//       return;
//     }

//     // Release the tab bar's hold on the mouse.
//     sender.releaseMouse();

//     // Setup the mime data for the drag operation.
//     let mimeData = new MimeData();
//     let widget = args.item as Widget;
//     mimeData.setData(FACTORY_MIME, () => widget);

//     // Create the drag image for the drag operation.
//     let tab = sender.tabAt(args.index);
//     let dragImage = tab.cloneNode(true) as HTMLElement;

//     // Create the drag object to manage the drag-drop operation.
//     currentDrag = new Drag({
//       mimeData: mimeData,
//       dragImage: dragImage,
//       proposedAction: DropAction.Move,
//       supportedActions: DropActions.Move,
//     });

//     // Start the drag operation and cleanup when done.
//     tab.classList.add(HIDDEN_CLASS);
//     currentDrag.start(args.clientX, args.clientY).then(() => {
//       currentDrag = null;
//       tab.classList.remove(HIDDEN_CLASS);
//     });
//   }

//   /**
//    * Handle the `widgetRemvoed` signal for a dock stacked panel.
//    */
//   function onWidgetRemoved(sender: StackedPanel, widget: Widget): void {
//     if (sender.childCount() === 0) {
//       removeTabPanel(sender.parent as DockTabPanel);
//     }
//   }
// }


  /**
   * Find the first dock tab panel for the given dock panel.
   *
   * This returns `null` if the dock panel has no content. It will throw
   * an error if the structure of the dock panel is found to be invalid.
   */
  export
  function findFirstTabPanel(root: DockPanelChild): DockTabPanel {
    while (root) {
      if (root instanceof DockTabPanel) {
        return root;
      }
      root = root.widgets.at(0) as DockPanelChild;
    }
    return null;
  }
