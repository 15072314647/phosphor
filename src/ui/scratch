
//   /**
//    * Insert a widget as a new panel above a reference widget.
//    *
//    * @param widget - The widget to insert into the dock panel.
//    *
//    * @param ref - The reference widget. If this is not provided, the
//    *   widget will be inserted at the top edge of the dock panel.
//    *
//    * @throws An error if either `widget` or `ref` is invalid.
//    */
//   insertTop(widget: Widget, ref?: Widget): void {
//     DockPanelPrivate.insertSplit(this, widget, ref, Orientation.Vertical, false);
//   }

//   /**
//    * Insert a widget as a new panel to the left of a reference widget.
//    *
//    * @param widget - The widget to insert into the dock panel.
//    *
//    * @param ref - The reference widget. If this is not provided, the
//    *   widget will be inserted at the left edge of the dock panel.
//    *
//    * @throws An error if either `widget` or `ref` is invalid.
//    */
//   insertLeft(widget: Widget, ref?: Widget): void {
//     DockPanelPrivate.insertSplit(this, widget, ref, Orientation.Horizontal, false);
//   }

//   /**
//    * Insert a widget as a new panel to the right of a reference widget.
//    *
//    * @param widget - The widget to insert into the dock panel.
//    *
//    * @param ref - The reference widget. If this is not provided, the
//    *   widget will be inserted at the right edge of the dock panel.
//    *
//    * @throws An error if either `widget` or `ref` is invalid.
//    */
//   insertRight(widget: Widget, ref?: Widget): void {
//     DockPanelPrivate.insertSplit(this, widget, ref, Orientation.Horizontal, true);
//   }

//   /**
//    * Insert a widget as a new panel below a reference widget.
//    *
//    * @param widget - The widget to insert into the dock panel.
//    *
//    * @param ref - The reference widget. If this is not provided, the
//    *   widget will be inserted at the bottom edge of the dock panel.
//    *
//    * @throws An error if either `widget` or `ref` is invalid.
//    */
//   insertBottom(widget: Widget, ref?: Widget): void {
//     DockPanelPrivate.insertSplit(this, widget, ref, Orientation.Vertical, true);
//   }

//   /**
//    * Insert a widget as a sibling tab before a reference widget.
//    *
//    * @param widget - The widget to insert into the dock panel.
//    *
//    * @param ref - The reference widget. If this is not provided, the
//    *   widget will be inserted as the first tab in the top-left panel.
//    *
//    * @throws An error if either `widget` or `ref` is invalid.
//    */
//   insertTabBefore(widget: Widget, ref?: Widget): void {
//     DockPanelPrivate.insertTab(this, widget, ref, false);
//   }

//   /**
//    * Insert a widget as a sibling tab after a reference widget.
//    *
//    * @param widget - The widget to insert into the dock panel.
//    *
//    * @param ref - The reference widget. If this is not provided, the
//    *   widget will be inserted as the last tab in the top-left panel.
//    *
//    * @throws An error if either `widget` or `ref` is invalid.
//    */
//   insertTabAfter(widget: Widget, ref?: Widget): void {
//     DockPanelPrivate.insertTab(this, widget, ref, true);
//   }

//   *
//    * Ensure the tab for the specified content widget is selected.
//    *
//    * @param widget - The content widget of interest.
//    *
//    * #### Notes
//    * If the widget is not contained in the dock panel, or is already
//    * the selected tab in its respective tab panel, this is a no-op.

//   selectWidget(widget: Widget): void {
//     DockPanelPrivate.selectWidget(this, widget);
//   }











/**
 * The namespace for the module private data.
 */
// namespace Private {








//   /**
//    * Ensure the given widget is the current widget in its tab panel.
//    *
//    * This is a no-op if the widget is not contained in the dock panel.
//    */
//   export
//   function selectWidget(owner: DockPanel, widget: Widget): void {
//     if (!dockPanelContains(owner, widget)) return;
//     (widget.parent.parent as DockTabPanel).currentWidget = widget;
//   }


//   /**
//    * The creation handler for the dock panel `overlayProperty`.
//    *
//    * This will create and install the overlay for the panel.
//    */
//   function createOverlay(owner: DockPanel): DockPanelOverlay {
//     let overlay = new DockPanelOverlay();
//     owner.node.appendChild(overlay.node);
//     return overlay;
//   }

//   /**
//    * Throw an internal dock panel error.
//    */
//   function internalError(): void {
//     throw new Error('Internal DockPanel Error.');
//   }



//   /**
//    * Find the ancestor dock tab panel for the given widget.
//    *
//    * This assumes the widget already belongs to a dock panel, and will
//    * throw an error if that assumption does not hold.
//    */
//   function findTabPanel(widget: Widget): DockTabPanel {
//     let stack = widget.parent;
//     if (!stack) {
//       internalError();
//     }
//     let tabs = stack.parent;
//     if (!(tabs instanceof DockTabPanel)) {
//       internalError();
//     }
//     return tabs as DockTabPanel;
//   }

//   /**
//    * Find the first dock tab panel for the given dock panel.
//    *
//    * This returns `null` if the dock panel has no content. It will throw
//    * an error if the structure of the dock panel is found to be invalid.
//    */
//   function findFirstTabPanel(owner: DockPanel): DockTabPanel {
//     let root = getRoot(owner);
//     while (root) {
//       if (root instanceof DockTabPanel) {
//         return root;
//       }
//       if (!(root instanceof DockSplitPanel) || root.childCount() === 0) {
//         internalError();
//       }
//       root = root.childAt(0) as RootPanel;
//     }
//     return null;
//   }

//   /**
//    * Get or create the first dock tab panel for the given dock panel.
//    *
//    * If dock panel has no root, a new tab panel will be created and
//    * added as the root. An error will be thrown if the structure of
//    * the dock panel is found to be invalid.
//    */
//   function ensureFirstTabPanel(owner: DockPanel): DockTabPanel {
//     let tabs = findFirstTabPanel(owner);
//     if (!tabs) {
//       tabs = createTabPanel();
//       setRoot(owner, tabs);
//     }
//     return tabs;
//   }


//   /**
//    * The current tab drag object.
//    */
//   let currentDrag: Drag = null;

//   /**
//    * Create a new tab panel for a dock panel.
//    */
//   function createTabPanel(): DockTabPanel {
//     let panel = new DockTabPanel();
//     panel.tabBar.tabDetachRequested.connect(onTabDetachRequested);
//     panel.stackedPanel.widgetRemoved.connect(onWidgetRemoved);
//     return panel;
//   }

//   /**
//    * Remove an empty dock tab panel from the hierarchy.
//    *
//    * This ensures that the hierarchy is kept consistent by merging an
//    * ancestor split panel when it contains only a single child widget.
//    */
//   function removeTabPanel(tabPanel: DockTabPanel): void {
//     // Assert the tab panel is empty.
//     if (tabPanel.childCount() !== 0) {
//       internalError();
//     }

//     // If the parent of the tab panel is a dock panel, just remove it.
//     if (tabPanel.parent instanceof DockPanel) {
//       setRoot(tabPanel.parent as DockPanel, null);
//       tabPanel.dispose();
//       return;
//     }

//     // Assert the tab panel parent is a dock split panel.
//     if (!(tabPanel.parent instanceof DockSplitPanel)) {
//       internalError();
//     }

//     // Cast the tab panel parent to a dock split panel.
//     let splitPanel = tabPanel.parent as DockSplitPanel;

//     // Assert the split panel has at least two children.
//     if (splitPanel.childCount() < 2) {
//       internalError();
//     }

//     // Dispose the tab panel to ensure its resources are released.
//     tabPanel.dispose();

//     // If the split panel still has multiple children, there is
//     // nothing more to do.
//     if (splitPanel.childCount() > 1) {
//       return;
//     }

//     // Extract the remaining child from the split panel.
//     let child = splitPanel.childAt(0);

//     // Assert the remaining child is a proper panel type.
//     if (!(child instanceof DockTabPanel) && !(child instanceof DockSplitPanel)) {
//       internalError();
//     }

//     // If the parent of the split panel is a dock panel, replace it.
//     if (splitPanel.parent instanceof DockPanel) {
//       setRoot(splitPanel.parent as DockPanel, child as RootPanel);
//       splitPanel.dispose();
//       return;
//     }

//     // Assert the split panel parent is a dock split panel.
//     if (!(splitPanel.parent instanceof DockSplitPanel)) {
//       internalError();
//     }

//     // Cast the split panel parent to a dock split panel.
//     let grandPanel = splitPanel.parent as DockSplitPanel;

//     // If the child is a dock tab panel, replace the split panel.
//     if (child instanceof DockTabPanel) {
//       let sizes = grandPanel.sizes();
//       let index = grandPanel.childIndex(splitPanel);
//       splitPanel.parent = null;
//       grandPanel.insertChild(index, child);
//       grandPanel.setSizes(sizes);
//       splitPanel.dispose();
//       return;
//     }

//     // Cast the child to a dock split panel.
//     let childSplit = child as DockSplitPanel;

//     // Child splitters have an orthogonal orientation to their parent.
//     // Assert the orientation of the child matches the grand parent.
//     if (childSplit.orientation !== grandPanel.orientation) {
//       internalError();
//     }

//     // The grand children can now be merged with their grand parent.
//     // Start by fetching the relevant current sizes and insert index.
//     let index = grandPanel.childIndex(splitPanel);
//     let childSizes = childSplit.sizes();
//     let grandSizes = grandPanel.sizes();

//     // Remove the split panel and store its share of the size.
//     splitPanel.parent = null;
//     let sizeShare = arrays.removeAt(grandSizes, index);

//     // Merge the grand children and maintain their relative size.
//     for (let i = 0; childSplit.childCount() !== 0; ++i) {
//       grandPanel.insertChild(index + i, childSplit.childAt(0));
//       arrays.insert(grandSizes, index + i, sizeShare * childSizes[i]);
//     }

//     // Update the grand parent sizes and dispose the removed panel.
//     grandPanel.setSizes(grandSizes);
//     splitPanel.dispose();
//   }

//   /**
//    * Handle the `tabDetachRequested` signal from a dock tab bar.
//    */
//   function onTabDetachRequested(sender: TabBar, args: ITabDetachArgs): void {
//     // Do nothing if a drag is already in progress.
//     if (currentDrag) {
//       return;
//     }

//     // Release the tab bar's hold on the mouse.
//     sender.releaseMouse();

//     // Setup the mime data for the drag operation.
//     let mimeData = new MimeData();
//     let widget = args.item as Widget;
//     mimeData.setData(FACTORY_MIME, () => widget);

//     // Create the drag image for the drag operation.
//     let tab = sender.tabAt(args.index);
//     let dragImage = tab.cloneNode(true) as HTMLElement;

//     // Create the drag object to manage the drag-drop operation.
//     currentDrag = new Drag({
//       mimeData: mimeData,
//       dragImage: dragImage,
//       proposedAction: DropAction.Move,
//       supportedActions: DropActions.Move,
//     });

//     // Start the drag operation and cleanup when done.
//     tab.classList.add(HIDDEN_CLASS);
//     currentDrag.start(args.clientX, args.clientY).then(() => {
//       currentDrag = null;
//       tab.classList.remove(HIDDEN_CLASS);
//     });
//   }

//   /**
//    * Handle the `widgetRemvoed` signal for a dock stacked panel.
//    */
//   function onWidgetRemoved(sender: StackedPanel, widget: Widget): void {
//     if (sender.childCount() === 0) {
//       removeTabPanel(sender.parent as DockTabPanel);
//     }
//   }
// }
